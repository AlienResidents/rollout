#!/usr/bin/perl -w
# Last step to be called
# Make a record of a Rollout run
# vim:tw=100 sw=2 expandtab ft=perl

if (!$safe_mode) {
  my $end_time = time;
  my $duration = abs($end_time - $start_time);

  # Record a log file of each rollout run
  my $fn = c("$hostname/rollout/logfile");
  if ($fn && (my $fh = new IO::File ">>$fn"))
  {
    my($host, $port) = ($ENV{SSH_CLIENT} || "console", "");
    if ($host =~ /(?:::ffff:)?(\d+\.\d+\.\d+\.\d+)\s+(\d+)\s+\d+/) {
      $host = $1 || "127.0.0.1";
      $port = $2 || 0;
      my $x = `host $host` || "";
      $host = $1 if $x =~ /domain name pointer (.*)\./;
    }

    print $fh "-------------------------------------------------\n";
    print $fh "START: ". localtime($start_time). "\n";
    print $fh "DURATION: $duration\n";
    print $fh "COMMENT: $rollout_comment\n";
    print $fh "FROM: $host $port\n";
    print $fh "HOSTNAME: $hostname\n";
    print $fh "\n$log\n";
    print $fh "\n";
  }

  # Uncomment this section to notify a central server of each rollout
#  eval
#  {
#    require URI::Escape;
#    import URI::Escape;
#    print http_post("$config->{base_url}/complete.php",
#      hostname  => $hostname,
#      on_host    => hostname,
#      start_time  => $start_time,
#      end_time  => $end_time,
#      duration  => $duration,
#      from    => $host,
#      from_port  => $port,
#      comment    => $rollout_comment,
#      'log'    => $log,
#    );
#
#    sub http_post
#    {
#      my($url, %v) = @_;
#
#      my($h, $p, $path) = $url =~ /^(?:http:\/\/)?([^\/:]+)(?::(\d+))?(\/?.*)/;
#      my $s = Net::HTTP->new(Host => $h, PeerPort => $p || 80) || return w $@;
#
#      $s->write_request(POST => $path, 'User-Agent' => "Rollout/1.0", 'Content-Type' => 'application/x-www-form-urlencoded', join("&", map { "$_=". uri_escape($v{$_}) } keys %v));
#      my($code, $mess, %h) = $s->read_response_headers;
#
#      if ($code != 200)
#      {
#        w "POST $url returned $code";
#        return undef;
#      }
#
#      my $res = "";
#      while (1)
#      {
#        my $buf;
#        my $n = $s->read_entity_body($buf, 1024);
#        fatal "Read failed: $!" unless defined $n;
#        last unless $n;
#        $res .= $buf;
#      }
#
#      return $res;
#    }
#  };
}

