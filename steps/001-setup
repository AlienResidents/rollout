#!/usr/bin/perl -w
# vim:tw=100 sw=2 expandtab ft=perl
=head1 setup

Retrieve the configuration and install rollout locally.

=head1 EXAMPLE

  rollout => {
    require_reason => 1,               # A reason for running rollout must be given on the command line
    logfile => "/var/log/rollout.log", # Log each run to this file
    reorder_steps => [                 # Change the order of steps
      "240-dir_check" => 140,
      "060-ssh_keys" => 170,
    ],
    copy_steps => [                    # Run a step multiple times during the run
      "800-file_append" => 850,
      "800-file_append" => 880,
    ],
  },
  command => [
    200 => 'ls /tmp',
    210 => sub { l "Hello world" },
  ],

=head1 SKIPPABLE STEPS

=over

=item local_install

Install rollout locally (in /usr/local/sbin)

=back

=head1 COPYRIGHT

Copyright 2010 David Parrish

=cut

use vars qw( %networks );

my $global_safe_mode = $safe_mode;
# This first step has to be done without safe mode
local $safe_mode = 0;

# Retreive and parse configuration {{{
try {
  my $machines_data = http_file "rollout.cfg";
  eval $machines_data;
  die "Can't parse rollout configuration rollout.cfg: $@" unless keys %m;
} catch HttpException with {
  fatal "Can't retrieve rollout configuration rollout.cfg: ". shift;
} catch Error with {
  fatal shift;
};

try {
  get_fragments("fragments");
} catch HttpException with {
  fatal "Error retrieving fragments: ". shift;
};

sub get_fragments {
  my ($location) = @_;
  my @fragments = http_index $location;
  foreach (sort { $a->{filename} cmp $b->{filename} } @fragments) {
    my $fragment = $_->{filename};
    if ($fragment =~ /\/$/) {
      # making the output look pretty in verbose
      $fragment =~ s/\/$//;
      get_fragments("$location/$fragment");
    } else {
      v "fragment: $location/$fragment";
      try {
        my $text = http_file "$location/$fragment";
        w "Empty config fragment \"$location/$fragment\"" and next unless $text;
        eval $text;
        if ($@) {
          fatal "Config fragment \"$location/$fragment\" failed: $@";
        }
      } catch HttpException with {
        w "Error retrieving config fragment $location/$fragment: ". shift;
      };
    }
  }
}

v "Evaluated Rollout config: ". scalar(grep /^[a-z]/, keys %m). " devices, ".
  scalar(grep /^[A-Z]/, keys %m). " classes";
fatal "Can't find configuration entry for $hostname" unless $m{$hostname};

# }}}

validate_step_config {
  command => {
    help => "List of commands to run at set priorities",
    type => "hash_list",
    key => {
      type => "int",
      help => "Step number",
      range => [1, 998],
    },
    value => {
      type => [ "string", "code" ],
      help => [ "Command to run", "Perl code to run" ],
    },
  },
  rollout => {
    type => "options",
    options => {
      reorder_steps => {
        help => "Change the ordering of steps",
        type => "hash_list",
        key => {
          type => "string",
          help => "Step",
          regex => qr/^\d+-[\w_\-.]+$/,
        },
        value => {
          type => "int",
          help => "Destination step number",
          range => [1, 998],
        },
      },
      copy_steps => {
        help => "Make a step run at multiple priorities",
        type => "hash_list",
        key => {
          type => "string",
          help => "Step",
          regex => qr/^\d+-[\w_\-.]+$/,
        },
        value => {
          type => "int",
          help => "Destination step number",
          range => [1, 998],
        },
      },
      require_reason => {
        type => "boolean",
        help => "Require a reason string for each run",
      },
      logfile => {
        type => "path",
        help => "File to log rollout run information to",
      },
    },
  },
  skip_steps => {
    help => "List of steps to skip",
    type => "list",
    items => {
      type => "string",
      help => "Step",
      regex => qr/^(\d+-)?[\w_\-.]+$/,
    },
  },
};

# Install rollout locally, keeping the rollout URL parameter permanently {{{
if (i_should("local_install") && !$safe_mode) {
  try {
    my $rollout = http_file "/rollout";

    my($rc, @output) = compile_perl($rollout);
    if ($rc) {
      l map { "$_\n" } @output;
      fatal "The rollout script could be not correctly parsed, and won't be installed";
      exit;
    }

    my $dest = $0;
    $dest = "/usr/local/sbin/rollout" unless $dest =~ /^\//;
    if (text_install(-file => $dest, -text => $rollout, -mode => 0750, -uid => 0, -group => 0 )) {
      # rollout has been updated, switch to it
      l "Rollout has been installed to $dest, re-executing";
      exec($dest, @ARGV);
    }
  } catch HttpException with {
    fatal "Can't download rollout to install locally: ". shift;
  };
}

# }}}

push @skip_steps, flatten_list(c("$hostname/skip_steps"));
if (c("$hostname/rollout/require_reason") &&
    (!$rollout_comment || $rollout_comment eq 'No comment specified') &&
    !$global_safe_mode) {
  # A comment is required, fail if none was provided
  fatal "You must enter a reason for this rollout run on the command line."
}

# Look for any "command" blocks and queue the commands
my @commands = flatten_list(c("$hostname/command"));
for (my $i = 0; $i < @commands; $i += 2) {
  my($prio, $cmd) = @commands[$i..$i + 1];
  $steps->insert(ref $cmd ? $cmd : sub { command($cmd) }, $prio);
}


# Build networks map {{{
sub _expand_network {
  my($network) = @_;
  return () unless $network;

  $network =~ s/(^\[|\]$)//g;
  return ($network) if $network =~ /^\d+\.\d+\.\d+\.\d+/;

  my @hosts;

  foreach my $d (keys %m) {
    next unless $m{$d}->{interfaces};
    next unless $m{$d}->{network} && grep { $_ eq $network } @{$m{$d}->{network}};

    foreach (values %{$m{$d}->{interfaces}}) {
      push @hosts, $_->{ip} if $_->{ip};
    }
  }
  return @hosts;
}

foreach (keys %m) {
  $m{$_}->{network} = [ $m{$_}->{network} ]
    if $m{$_}->{network} && ref $m{$_}->{network} ne 'ARRAY';
}

foreach my $n (map { $_->{network} } grep { $_->{network} } values %m) {
  foreach my $network (@$n) {
    $networks{$network} ||= [];
    foreach my $host (_expand_network($network)) {
      push @{$networks{$network}}, $host unless grep { $_ eq $host } @{$networks{$network}};
    }
  }
}

foreach my $d (grep { $m{$_}->{ISA} } keys %m) {
  next unless $m{$d}->{interfaces};
  foreach (i_isa_classes($d)) {
    $networks{$_} ||= [];
    foreach my $i (values %{$m{$d}->{interfaces}}) {
      push @{$networks{$_}}, $i->{ip} if $i->{ip};
    }
  }

  foreach my $i (values %{$m{$d}->{interfaces}}) {
    next unless $i->{ip};
    $networks{$d} ||= [];
    push @{$networks{$d}}, $i->{ip};
  }
}

# }}}
sub compile_perl { # {{{
  my($code) = @_;
  my $pid;

  use POSIX ":sys_wait_h";
  use IPC::Open2;

  local $SIG{CHLD} = sub {
    waitpid(-1, WNOHANG);
    $pid = 0;
  };

  my($rd, $wr);
  $pid = open2($rd, $wr, "$^X -wc - 2>&1");
  print $wr $code;
  close $wr;
  my @output;
  while (<$rd>) {
    chomp;
    push @output, $_;
  }
  close($wr);

  pop @output if @output && $output[$#output] =~ /^- (?:syntax OK|had compilation errors)/;

  while ($pid) {sleep(1)}

  return wantarray ? ($?, @output) : $?;
}
# }}}

