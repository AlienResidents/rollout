#!/usr/bin/perl -w
# Install all required packages
# vim:tw=100 sw=2 expandtab ft=perl
#
# Available skip_steps items:
#  apt_sources - Configure apt repositories
#  deb_options - Preconfigure .deb options before installation
#  install - Install packages
#  remove - Remove packages
#
# Example:
# packages => [ 'package1', 'package2' ],

validate_config {
  packages => {
    help => "Packages to install",
    type => "list",
    items => {
      help => "Package name",
      type => "string",
    },
  },
  packages_remove => {
    help => "Packages to remove",
    type => "list",
    items => {
      help => "Package name",
      type => "string",
    },
  },
  apt_base => {
    help => "List of apt sources to add to /etc/apt/sources.list.d/rollout.list",
    type => "list",
    items => { type => "string" },
  },
  deb_options => {
    help => "List of options to run through debconf-set-selections",
    type => "list",
    items => { type => "string" },
  },
  yum => {
    help => "Configuration for the Yellowdog Updater Modified",
    type => "options",
    options => {
      auto_upgrade => {
        type => "boolean",
        help => "Whether all installed packages will be upgraded when Rollout is run",
      },
      repos => {
        type => "hash",
        key => {
          type => "string",
        },
        value => {
          type => "options",
          options => {
            name => { type => "string" },
            baseurl => { type => "string" },
            mirrorlist => { type => "string" },
            failovermethod => { type => "string" },
            enabled => { type => "boolean" },
            gpgcheck => { type => "boolean" },
            gpgkey => { type => "string" },
          },
        },
      },
    },
  },
  pkgutil => {
    help => "Configuration for the Solaris package manager",
    type => "options",
    options => {
      auto_upgrade => {
        type => "boolean",
        help => "Whether all installed packages will be upgraded when Rollout is run",
      },
    },
  },
  emerge => {
    help => "Configuration for the Gentoo portage manager",
    type => "options",
    options => {
      auto_upgrade => {
        type => "boolean",
        help => "Whether all installed packages will be upgraded when Rollout is run",
      },
    },
  },
  up2date => {
    help => "Configuration for the RedHat Enterprise Linux package manager",
    type => "options",
    options => {
      command => {
        type => "string",
      },
      auto_upgrade => {
        type => "boolean",
        help => "Whether all installed packages will be upgraded when Rollout is run",
      },
    },
  },
};

# Get lists of packages to add and remove
my @install = i_should("install")
    ? grep { i_should("add-$_") } uniq(flatten_list(c("$hostname/packages")))
    : ();
my @remove = i_should("remove")
    ? grep { i_should("remove-$_") } uniq(flatten_list(c("$hostname/packages_remove")))
    : ();

return unless @install || @remove;

# Check for packages that are to be installed and removed
foreach my $package (@remove) {
  throw ConfigException "Attempt to both remove and install package '$package'. Naughty."
    if grep /^\Q$package\E$/, @install;
}

# {{{ Apt
if (-x "/usr/bin/apt-get") {
  # APT for package installation (Debian / Ubuntu)
  my @apt = uniq(flatten_list(c("$hostname/apt_base")));
  text_install(-file => "/etc/apt/sources.list.d/rollout.list",
               -text => join("", map { "$_\n" } @apt),
               -mode => 0644, -uid => 0, -gid => 0)
      if @apt && i_should("apt_sources");

  if (i_should("deb_options") && i_has("deb_options") && -f "/usr/bin/debconf-set-selections") {
    my $text = join("\n", uniq(flatten_list(c("$hostname/deb_options")))). "\n";
    if ($text && open(DEBCONF, "|debconf-set-selections")) {
      print DEBCONF $text;
      close(DEBCONF);
    }
  }
  package_check(map { s/\.(?:32|64)bit$//; $_ } @install) if @install;
  package_uncheck(map { s/\.(?:32|64)bit$//; $_ } @remove) if @remove;
}
# }}}
# {{{ Yum
elsif (-x "/usr/bin/yum") {
  my @do_install;
  my @will_update;
  if (c("$hostname/yum/repos")) {
    my %config;
    my %c = flatten_hash(c("$hostname/yum/repos"));
    while (my($item, $value) = each(%c)) {
      $config{$item} = [];
      foreach (keys %$value) {
        push @{$config{$item}}, $_, $value->{$_};
      }
    }
    config_file(-file => "/etc/yum.repos.d/rollout.repo", -sections => \%config, -type => "ini");
  }
  if (@install || c("$hostname/yum/auto_upgrade")) {
    l "Updating YUM metadata cache";
    command("yum", "makecache");
  }
  if (@install) {
    # Check that all required packages are either installed or up-to-date
    v "Checking for packages that require updates";
    open(FH, "/usr/bin/yum check-update|") or throw LocalFileException "Could not run yum: $!";
    # Read the header
    while (<FH>) { last if /^\s+$/ }
    while (<FH>) {
      chomp;
      s/^(\s+|\s+$)//g;
      my($package, $version, $extra) = split /\s+/, $_, 3;
      $package =~ s/\.[a-z0-9+]+$//;
      next unless $package;
      push @do_install, grep { /^\Q$package\E(?:\.[a-z0-9]+)?$/ } @install;
      push @will_update, $package unless grep /^\Q$package\E$/, @install;
    }
    close(FH);
    v "Updating packages: ". join(" ", @do_install) if @do_install;
  }
  if ((@install && @do_install != @install) || @remove) {
    my %installed_packages;
    v "Building list of installed packages";
    open(FH, "/bin/rpm -q -a --queryformat '%{NAME}\n'|")
        or throw LocalFileException "Could not run rpm: $!";
    while (<FH>) {
      chomp;
      $installed_packages{$_}++;
    }
    close(FH);

    push @do_install, grep { !$installed_packages{$_} } @install;
    my @do_remove = grep { $installed_packages{$_} } @remove;

    if (@do_install) {
      l "Installing packages: ". join(" ", uniq(@do_install)). "\n";
      command("yum", "install", "-y", uniq(@do_install));
    }

    if (@do_remove) {
      l "Removing packages: ". join(" ", @do_remove);
      command("yum", "remove", "-y", uniq(@do_remove));
    }
  }
  if (c("$hostname/yum/auto_upgrade")) {
    if ((@install && @will_update) || !@install) {
      l "Upgrading all installed packages";
      command("yum", "upgrade", "-y");
    }
  }
}
# }}}
# {{{ Pkgutil (Solaris)
elsif (-f "/opt/csw/bin/pkgutil") {
  my %available_packages;
  my %can_upgrade;
  my %installed_packages;

  v "Building list of available packages";
  open(FH, "/opt/csw/bin/pkgutil -a|") or throw LocalFileException "Could not run pkgutil: $!";
  while (<FH>) {
    chomp;
    my($package, $shortname, $version, $extra) = split /\s+/, $_, 4;
    $available_packages{$package} = $shortname;
  }

  v "Building list of installed packages";
  open(FH, "/opt/csw/bin/pkgutil -c|") or throw LocalFileException "Could not run pkgutil: $!";
  <FH>;
  while (<FH>) {
    s/\s+$//;
    my($package, $installed, $catalog) = split /\s+/, $_, 3;
    $installed_packages{$package} = $package;
    $can_upgrade{$package}++ unless $catalog eq 'SAME';
  }

  if (@install) {
    my @do_install = uniq(grep {
      (!$installed_packages{$_} && !$installed_packages{$available_packages{$_}}) ||
      ($can_upgrade{$_} || $can_upgrade{$available_packages{$_}})
    } @install);
    if (@do_install) {
      l "Installing packages: ". join(" ", @do_install);
      command("/opt/csw/bin/pkgutil", "-y", "-i", @do_install);
      delete $can_upgrade{@do_install};
    }
  }

  if (@remove) {
    my @do_remove = uniq(grep { defined } map {
      $installed_packages{$_} || $installed_packages{$available_packages{$_}}
    } @remove);
    if (@do_remove) {
      l "Removing packages: ". join(" ", @do_remove);
      command("/opt/csw/bin/pkgutil", "-y", "-r", @do_remove);
    }
  }

  if (c("$hostname/pkgutil/auto_upgrade") && %can_upgrade) {
    l "Upgrading all installed packages";
    command("/opt/csw/bin/pkgutil", "-y", "-u");
  }
}
elsif (i_os("solaris")) {
  w "Solaris package management is supported using pkgutil (http://pkgutil.wikidot.com/) only";
}
# }}}
# {{{ FreeBSD Packages
elsif (i_os("freebsd") && -f "/usr/sbin/pkg_add") {
  my %installed_packages;
  if (open(FH, "/usr/sbin/pkg_info|")) {
    v "Building list of installed packages";
    while (<FH>) {
      chomp;
      my($package, $extra) = split /\s+/, $_, 2;
      $installed_packages{$package} = $package;
    }
  }
  my @do_install;
  foreach my $package (@install) {
    push @do_install, $package unless grep /^\Q$package\E(?:-.*)?$/, keys %installed_packages;
  }
  if (@do_install) {
    l "Installing packages: ". join(" ", @do_install);
    command("/usr/sbin/pkg_add", "-r", @do_install);
  }

  my @do_remove;
  foreach my $package (@remove) {
    push @do_remove, grep { $_ } map { $_ if grep /^\Q$package\E(?:-.*)?$/, $_ }
        keys %installed_packages;
  }
  if (@do_remove) {
    l "Removing packages: ". join(" ", @do_remove);
    command("/usr/sbin/pkg_delete", @do_remove);
  }

  # Automatic upgrades are not supported by these package tools
  # TODO(dparrish): Add some kind of port management here
}
# }}}
# {{{ Gentoo Portage
elsif (-f "/usr/bin/emerge") {
  my @do_install;
  my @do_upgrade;
  my $basedir = "/usr/portage";
  foreach my $package (@install) {
    if (!-d "$basedir/$package") {
      my @matches = glob("$basedir/*/$package");
      w "Couldn't find package $package" and next unless @matches;
      throw ConfigException "Multiple packages found installing '$package', specify category too"
        if @matches > 1;
      next unless -d $matches[0];
      $matches[0] =~ s/^$basedir\/*//;
      $package = $matches[0];
    }
    my($category, $shortpackage) = split /\//, $package;
    open(FH, "<$basedir/$package/Manifest")
      or throw LocalFileException "Couldn't read $basedir/$package/Manifest: $!";
    my $latest_version = "";
    while (<FH>) {
      next unless /^EBUILD $shortpackage-(.*?)\.ebuild/;
      $latest_version = $1;
    }
    # Skip installing if the installed version is the latest
    next if $latest_version && -d "/var/db/pkg/$package-$latest_version";

    if (uniq(glob("/var/db/pkg/$package-*"), glob("/var/db/pkg/*/$package-*"), glob("/var/db/pkg/*/$package")) || -d "/var/db/pkg/$package") {
      push @do_upgrade, $package;
    } else {
      push @do_install, $package;
    }
  }

  if (@do_install) {
    l "Installing packages: ". join(" ", uniq(@do_install));
    command("emerge", uniq(@do_install));
  }
  if (@do_upgrade) {
    l "Upgrading packages: ". join(" ", uniq(@do_upgrade));
    command("emerge", "-uD", uniq(@do_upgrade));
  }

  my @do_remove;
  foreach my $package (@remove) {
    my $found;
    push @do_remove, $found = $package if -d "/var/db/pkg/$package";
    push @do_remove, map { s!^/var/db/pkg/!!; $_ } grep { /^\/var\/db\/pkg/ }
                         uniq(glob("/var/db/pkg/$package-*"), glob("/var/db/pkg/*/$package-*"),
                              glob("/var/db/pkg/*/$package")) unless $found;;
  }

  if (@do_remove) {
    l "Removing packages: ". join(" ", uniq(@do_remove));
    command("emerge", "--unmerge", uniq(@do_remove));
  }

  if (c("$hostname/emerge/auto_upgrade")) {
    l "Upgrading all installed packages";
    command("emerge", "-uD", "world");
  }
}
# }}}
# {{{ RedHat Enterprise
elsif (i_os("linux") && i_distro("redhat") && -x "/usr/bin/up2date-nox") {
  my $cmd = c("$hostname/up2date/command") || "/usr/bin/up2date-nox";
  my %installed_packages;
  v "Building list of installed packages";
  open(FH, "/bin/rpm -q -a --queryformat '%{NAME}\n'|")
      or throw LocalFileException "Could not run rpm: $!";
  while (<FH>) {
    chomp;
    $installed_packages{$_}++;
  }
  close(FH);

  my @do_install = grep { !$installed_packages{$_} } @install;;
  if (@do_install) {
    l "Installing packages: ". join(" ", uniq(@do_install));
    command($cmd, "-i", uniq(@do_install));
  }

  my @do_remove = grep { $installed_packages{$_} } @remove;;
  if (@do_remove) {
    l "Removing packages: ". join(" ", uniq(@do_remove));
    command("rpm", "-e", uniq(@do_remove));
  }

  if (c("$hostname/up2date/auto_upgrade")) {
    l "Upgrading all installed packages";
    command($cmd, "-u");
  }
}
# }}}
else {
  w "Don't know how to manage packages on ". i_os(). " ". i_distro();
}

