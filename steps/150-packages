#!/usr/bin/perl -w
# Install all required packages
# vim:tw=100 sw=2 expandtab ft=perl
#
# Available skip_steps items:
#  apt_sources - Configure apt repositories
#  deb_options - Preconfigure .deb options before installation
#  install - Install packages
#  remove - Remove packages
#
# Example:
# packages => [ 'package1', 'package2' ],

validate_config {
  packages => {
    help => "Packages to install",
    type => "list",
    items => {
      help => "Package name",
      type => "string",
    },
  },
  packages_remove => {
    help => "Packages to remove",
    type => "list",
    items => {
      help => "Package name",
      type => "string",
    },
  },
  apt_base => {
    help => "List of apt sources to add to /etc/apt/sources.list.d/rollout.list",
    type => "list",
    items => { type => "string" },
  },
  deb_options => {
    help => "List of options to run through debconf-set-selections",
    type => "list",
    items => { type => "string" },
  },
  yum => {
    help => "Configuration for the Yellowdog Updater Modified",
    type => "options",
    options => {
      auto_upgrade => {
        type => "boolean",
        help => "Whether all installed packages will be upgraded when Rollout is run",
      },
    },
  },
  pkgutil => {
    help => "Configuration for the Solaris package manager",
    type => "options",
    options => {
      auto_upgrade => {
        type => "boolean",
        help => "Whether all installed packages will be upgraded when Rollout is run",
      },
    },
  },
};

# Get lists of packages to add and remove
my @install = i_should("install")
    ? grep { i_should("add-$_") } uniq(flatten_list(c("$hostname/packages")))
    : ();
my @remove = i_should("remove")
    ? grep { i_should("remove-$_") } uniq(flatten_list(c("$hostname/packages_remove")))
    : ();

return unless @install || @remove;

# Check for packages that are to be installed and removed
foreach my $package (@remove) {
  throw ConfigException "Attempt to both remove and install package '$package'. Naughty."
    if grep /^\Q$package\E$/, @install;
}

# {{{ Apt
if (-x "/usr/bin/apt-get") {
  # APT for package installation (Debian / Ubuntu)
  my @apt = uniq(flatten_list(c("$hostname/apt_base")));
  text_install(-file => "/etc/apt/sources.list.d/rollout.list",
               -text => join("", map { "$_\n" } @apt),
               -mode => 0644, -uid => 0, -gid => 0)
      if @apt && i_should("apt_sources");

  if (i_should("deb_options") && i_has("deb_options") && -f "/usr/bin/debconf-set-selections") {
    my $text = join("\n", uniq(flatten_list(c("$hostname/deb_options")))). "\n";
    if ($text && open(DEBCONF, "|debconf-set-selections")) {
      print DEBCONF $text;
      close(DEBCONF);
    }
  }
  package_check(map { s/\.(?:32|64)bit$//; $_ } @install) if @install;
  package_uncheck(map { s/\.(?:32|64)bit$//; $_ } @remove) if @remove;
}
# }}}
# {{{ Yum
elsif (-x "/usr/bin/yum") {
  my @do_install;
  my @will_update;
  if (@install || c("$hostname/yum/auto_upgrade")) {
    l "Updating YUM metadata cache";
    command("yum", "makecache");
  }
  if (@install) {
    # Check that all required packages are either installed or up-to-date
    v "Checking for packages that require updates";
    if (open(FH, "/usr/bin/yum check-update|")) {
      # Read the header
      while (<FH>) { last if /^\s+$/ }
      while (<FH>) {
        chomp;
        s/^(\s+|\s+$)//g;
        my($package, $version, $extra) = split /\s+/, $_, 3;
        $package =~ s/\.[a-z0-9+]+$//;
        next unless $package;
        push @do_install, grep { /^\Q$package\E(?:\.[a-z0-9]+)?$/ } @install;
        push @will_update, $package unless grep /^\Q$package\E$/, @install;
      }
      close(FH);
    }
    v "Updating packages: ". join(" ", @do_install) if @do_install;
  }
  if ((@install && @do_install != @install) || @remove) {
    my %installed_packages;
    v "Building list of installed packages";
    if (open(FH, "/bin/rpm -q -a --queryformat '%{NAME}\n'|")) {
      while (<FH>) {
        chomp;
        $installed_packages{$_}++;
      }
      close(FH);
    }

    push @do_install, grep { !$installed_packages{$_} } @install;
    my @do_remove = grep { $installed_packages{$_} } @remove;

    if (@do_install) {
      l "Installing packages: ". join(" ", uniq(@do_install)). "\n";
      command("yum", "install", "-y", uniq(@do_install));
    }

    if (@do_remove) {
      l "Removing packages: ". join(" ", @do_remove);
      command("yum", "remove", "-y", uniq(@do_remove));
    }
  }
  if (c("$hostname/yum/auto_upgrade")) {
    if ((@install && @will_update) || !@install) {
      l "Upgrading all installed packages";
      command("yum", "upgrade", "-y");
    }
  }
}
# }}}
# {{{ Pkgutil (Solaris)
elsif (-f "/opt/csw/bin/pkgutil") {
  my %available_packages;
  my %can_upgrade;
  my %installed_packages;

  if (open(FH, "/opt/csw/bin/pkgutil -a|")) {
    v "Building list of available packages";
    while (<FH>) {
      chomp;
      my($package, $shortname, $version, $extra) = split /\s+/, $_, 4;
      $available_packages{$package} = $shortname;
    }
  }

  if (open(FH, "/opt/csw/bin/pkgutil -c|")) {
    v "Building list of installed packages";
    <FH>;
    while (<FH>) {
      s/\s+$//;
      my($package, $installed, $catalog) = split /\s+/, $_, 3;
      $installed_packages{$package} = $package;
      $can_upgrade{$package}++ unless $catalog eq 'SAME';
    }
  }

  if (@install) {
    my @do_install = uniq(grep {
      (!$installed_packages{$_} && !$installed_packages{$available_packages{$_}}) ||
      ($can_upgrade{$_} || $can_upgrade{$available_packages{$_}})
    } @install);
    if (@do_install) {
      l "Installing packages: ". join(" ", @do_install);
      command("/opt/csw/bin/pkgutil", "-y", "-i", @do_install);
      delete $can_upgrade{@do_install};
    }
  }

  if (@remove) {
    my @do_remove = uniq(grep { defined } map {
      $installed_packages{$_} || $installed_packages{$available_packages{$_}}
    } @remove);
    if (@do_remove) {
      l "Removing packages: ". join(" ", @do_remove);
      command("/opt/csw/bin/pkgutil", "-y", "-r", @do_remove);
    }
  }

  if (c("$hostname/pkgutil/auto_upgrade") && %can_upgrade) {
    l "Upgrading all installed packages";
    command("/opt/csw/bin/pkgutil", "-y", "-u");
  }
}
elsif (i_os("solaris")) {
  w "Solaris package management is supported using pkgutil (http://pkgutil.wikidot.com/) only";
}
# }}}
# {{{ FreeBSD Packages
elsif (i_os("freebsd") && -f "/usr/sbin/pkg_add") {
  my %installed_packages;
  if (open(FH, "/usr/sbin/pkg_info|")) {
    v "Building list of installed packages";
    while (<FH>) {
      chomp;
      my($package, $extra) = split /\s+/, $_, 2;
      $installed_packages{$package} = $package;
    }
  }
  my @do_install;
  foreach my $package (@install) {
    push @do_install, $package unless grep /^\Q$package\E(?:-.*)?$/, keys %installed_packages;
  }
  if (@do_install) {
    l "Installing packages: ". join(" ", @do_install);
    command("/usr/sbin/pkg_add", "-r", @do_install);
  }

  my @do_remove;
  foreach my $package (@remove) {
    push @do_remove, grep { $_ } map { $_ if grep /^\Q$package\E(?:-.*)?$/, $_ }
        keys %installed_packages;
  }
  if (@do_remove) {
    l "Removing packages: ". join(" ", @do_remove);
    command("/usr/sbin/pkg_delete", @do_remove);
  }

  # Automatic upgrades are not supported by these package tools
  # TODO(dparrish): Add some kind of port management here
}
# }}}
else {
  w "Don't know how to manage packages on ". i_os(). " ". i_distro();
}

