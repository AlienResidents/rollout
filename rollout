#!/usr/bin/perl -w
# vim:tw=100 sw=2 expandtab ft=perl
#
#    Rollout
#    Copyright (C) 2007 David Parrish
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#

use strict;
use Carp;
use Error ':try';
use Fcntl ':flock';
use File::Basename;
use Getopt::Long;
use IO::File;
use IO::Select;
use POSIX 'setsid';
use Socket;
use Sys::Hostname;
eval {
  require Memoize;
  import Memoize;
};

use vars qw( $config $verbosity $safe_mode @skip_steps @force_dangerous %networks @only_steps
             $rollout_comment $start_time $configfile $configdir $VERSION %m $no_step_labels
             $validate_mode );
$VERSION = "1.2.0";
$verbosity = 1;
$safe_mode = 0;
$configdir = "/etc/rollout";
$no_step_labels = 0;
$config = {
  # This is the default configuration
  base_url => "http://rollout.domain",
  client_certificate => "cert.pem",
  client_certificate_key => "cert.key",
  ca_certificate => "cacert.crt",
};
my $hostname = hostname;
my @step_help;

# Parse some initial options
my @oldargv = @ARGV;
Getopt::Long::Configure(qw( default bundling auto_version pass_through ));
Getopt::Long::GetOptions(
  "configdir=s"     => \$configdir,
  "configfile=s"    => \$configfile,
  "quiet|q"         => sub { $verbosity = 0 },
  "verbose|v"       => sub { $verbosity++ },
);
@ARGV = @oldargv;

# Global variables
$hostname =~ s/\..*//;
my(@all_steps, $steps, %steps_code, $current_step);
$configfile ||= "$configdir/rollout.cfg";
$configfile = "$configdir/$configfile" unless $configfile =~ /^\//;
my $log = "";
$rollout_comment = join(" ", @ARGV) || "No comment specified";
$rollout_comment =~ s/(^['"]|['"]$)//g;
my $pid = $$;

# Exceptions {{{

package RolloutException;
use base 'Error';
use overload ('""' => 'stringify');
sub new {
  my($self) = shift;
  my $text = "". shift;
  my @args = ();
  local $Error::Depth = $Error::Depth + 1;
  local $Error::Debug = 1;
  $self->SUPER::new(-text => $text, @args);
}
1;

package HttpException;
use base 'RolloutException';
1;

package LocalFileException;
use base 'RolloutException';
1;

package ConfigException;
use base 'RolloutException';
1;

package StepHelpException;
use base 'RolloutException';
1;

package ConfigValidationException;
use base 'RolloutException';
1;

package ValidationCompleteException;
use base 'RolloutException';
1;

package SafeModeException;
use base 'RolloutException';
1;

package main;

# }}}
# Logging wrappers {{{
sub l(@) {
  my($text, $indent) = @_;
  return unless $verbosity && defined $text;
  $indent = 2 unless defined $indent;
  $indent = " " x $indent;
  my $newtext = $text;
  $newtext =~ s/^/$indent/mg;
  print "$newtext\n";
  $log .= "$text\n";
  return 0;
}

sub w(@) {
  my($text, $indent) = @_;
  return 1 unless $text;
  $indent = 2 unless defined $indent;
  $indent = " " x $indent;
  my $newtext = $text;
  $newtext =~ s/^/${indent}WARNING: /mg;
  print "$newtext\n";
  $log .= "$text\n";
}

sub fatal(@) {
  print "------ FATAL ERROR ------\n";
  if ($verbosity >= 3) {
    carp "$_\n" foreach (grep { defined $_ } @_);
  } else {
    print "$_\n" foreach (grep { defined $_ } @_);
  }
  print "Current Step: $current_step\n" if $current_step;
  exit 1 if $current_step;
  return 1;
}

sub d($) {
  eval {
    require Data::Dumper;
    return v(Data::Dumper::Dumper(@_)) if $verbosity >= 3;
  };
  return 1;
};
sub v(@) { l(@_) if $verbosity >= 2; return 1 }

# }}}
# RolloutHTTP package {{{

package RolloutHTTP;

use vars qw( $ua %per_host_certs $done_setup $use_lwp $use_sock );

sub _setup {
  return if $done_setup;
  $done_setup = 1;
  eval {
    # See if LWP is supported (for HTTPS)
    require LWP::UserAgent;
    require LWP::ConnCache;
    require HTTP::Request;
    require Net::SSLeay;

    *LWP::Protocol::https::_extra_sock_opts = sub {
      my($self, $host, $port) = @_;
      return SSL_ca_file => "$::configdir/$::config->{ca_certificate}",
          %{$per_host_certs{"$host:$port"} || {}};
    };

    if (!$ua) {
      $ua = new LWP::UserAgent;
      $ua->conn_cache(new LWP::ConnCache);
      $ua->agent("Rollout/$::VERSION");
    }
    $use_lwp = 1;
  };
  if ($@) {
    ::w "Error loading the SSL modules. SSL is disabled. Installing libwww and Net::SSLeay." if $@;
    eval { require Net::HTTP; };
    if ($@) {
      $use_sock = 1;
      ::w("Couldn't load any HTTP modules, falling back to direct socket IO. Install libwww!");
    } else {
    }
  }
}

sub add_client_cert {
  my($self, $host, $port, $cert_file, $key_file) = @_;
  $per_host_certs{"$host:$port"} = {
    SSL_cert_file => $cert_file,
    SSL_key_file => $key_file,
  };
}

sub new {
  my($class) = @_;
  _setup();
  my $self = bless {}, $class;
  return $self;
}

sub get {
  my($self, $url, $data_cb) = @_;
  my $len = 0;
  if ($use_lwp) {
    my $req = new HTTP::Request('GET', $url);
    my $res = $ua->request($req, sub {
      my($chunk, $res, $proto) = @_;
      $self->{res} = $res;
      $self->{code} = $res->code;
      $self->{message} = $res->message;
      $data_cb->($chunk);
      $len += length($chunk);
    });
    if (!$res || !$res->is_success) {
      $self->{message} = $res->status_line;
      throw HttpException($res->status_line);
    } else {
      $self->{message} = "OK";
    }
  } elsif ($use_sock) {
    require IO::Socket::INET;
    my($protocol, $host, $port, $path) = $url =~ /^(?:(https?):\/\/)?([^\/:]+)(?::(\d+))?(\/?.*)/;
    ::fatal("HTTPS is not supported without the Net::SSLeay module") if $protocol eq 'https';
    my $sock = IO::Socket::INET->new(PeerAddr => $host, PeerPort => $port)
      or ::fatal("Couldn't create socket to $host:$port");
    print $sock "GET $path HTTP/1.0\r\n";
    print $sock "Host: $host\r\n";
    print $sock "\r\n";
    chomp(my $header = <$sock>);
    ::fatal("Error retrieving http://$host:$port/$path: $header")
      unless $header =~ /^HTTP\/\d+\.\d+ (2\d\d) (.*)[\r\n]+$/;
    $self->{code} = $1;
    $self->{message} = $2;
    while (<$sock>) {
      # Ignore headers
      s/[\r\n]+$//;
      last if /^$/;
    }
    my $buf;
    while (<$sock>) {
      $data_cb->($_);
      $len += length $_;
    }
    $sock->close;
  } else {
    my($protocol, $host, $port, $path) = $url =~ /^(?:(https?):\/\/)?([^\/:]+)(?::(\d+))?(\/?.*)/;
    ::fatal("HTTPS is not supported without the Net::SSLeay module") if $protocol eq 'https';
    if (!$@) {
      my $req = new Net::HTTP Host => $host, PeerPort => $port || 80, Protocol => $protocol;
      if (!$req) {
        $self->{message} = $@;
        throw HttpException($@);
      }

      $req->write_request(GET => $path, 'User-Agent' => "Rollout/$::VERSION");
      ($self->{code}, $self->{message}) = $req->read_response_headers;
      my $buf;
      while (1) {
        my $n = $req->read_entity_body($buf, 4096);
        last unless $n;
        $data_cb->($buf);
        $len += $n;
      }
    }
  }
  return $len;
}

sub error_message {
  my($self) = @_;
  if ($use_lwp) {
    return undef if $self->{res} && $self->{res}->is_success();
    return $self->{message};
  } else {
    return $self->{message};
  }
}

sub is_success {
  my($self) = @_;
  if ($use_lwp) {
    return $self->{res}->is_success();
  } else {
    return $self->{code} =~ /^2../;
  }
}

package main;
# }}}
sub named_params(\@$) { #{{{
  my($params, $defaults) = @_;
  return undef unless $params && @$params;
  return $params->[0] if ref $params->[0] eq 'HASH' && @$params == 1;
  my $return = {};

  if (@$params % 2 != 0 || $params->[0] !~ /^-/) {
    # Positional parameters
    my @order;
    for (my $i = 0; $i < @$defaults; $i += 2) {
      my($key, $value) = ($defaults->[$i], $defaults->[$i + 1]);
      push @order, $key;
    }
    return $params unless @order;

    foreach (@order) {
      last unless @$params;
      $_ = "-$_" unless /^-/;
      $return->{$_} = shift @$params;
    }

    return $return;
  }

  # Named parameters
  for (my $i = 0; $i < @$defaults; $i += 2) {
    my($key, $value) = ($defaults->[$i], $defaults->[$i + 1]);
    $return->{$key} = $value if defined $value;
  }

  for (my $i = 0; $i < @$params; $i += 2) {
    my($key, $value) = ($params->[$i], $params->[$i + 1]);
    $return->{$key} = $value;
  }
  return $return;
}
#}}}
# HTTP functions {{{

sub http_file(@) {
  my $p = named_params @_, [ -url => undef, -dest => undef ];
  my $file = $p->{-url};
  return undef unless $file;

  my $url = $file =~ /^https?:\/\// ? $file : "$config->{base_url}/$file";

  my $req = new RolloutHTTP;
  my($protocol, $host, $port, $path) = $url =~ /^(?:(https?):\/\/)?([^\/:]+)(?::(\d+))?(\/?.*)/;
  if ($protocol eq 'https') {
    $ENV{HTTPS_CERT_FILE} = "$::configdir/$::config->{client_certificate}";
    $ENV{HTTPS_KEY_FILE} = "$::configdir/$::config->{client_certificate_key}";
    $ENV{HTTPS_CA_FILE} = "$::configdir/$::config->{ca_certificate}";
    $req->add_client_cert($host, $port, "$::configdir/$::config->{client_certificate}",
                          "$::configdir/$::config->{client_certificate_key}");
  }

  my $fh;
  my $first = 1;
  my $res = "";
  $req->get($url, sub {
    my($chunk) = @_;
    if ($first) {
      throw HttpException "GET $url returned $req->{code}" unless $req->is_success;
      if ($p->{-dest}) {
        v "Writing to $p->{-dest}.$$";
        if (!($fh = new IO::File ">$p->{-dest}.$$")) {
          throw HttpException "Can't write to $p->{-dest}.$$: $!";
        }
      }
      $first = 0;
    }
    if ($fh) {
      if (!$fh->write($chunk)) {
        $fh->close;
        unlink("$p->{-dest}.$$");
        throw LocalFileException "Error writing to $p->{-dest}.$$: $!";
      }
      $res += length($chunk);
    } else {
      $res .= $chunk;
    }
    return $res;
  });

  if ($p->{-dest} && $fh) {
    $fh->close;
    if (-f $p->{-dest} && -s $p->{-dest} && !-s "$p->{-dest}.$$") {
      unlink "$p->{-dest}.$$";
      throw HttpException "Not overwriting existing file with nothing";
    }
    throw LocalFileException "Unable to rename $p->{-dest}.$$ to $p->{-dest}" unless
      rename("$p->{-dest}.$$", $p->{-dest});
  }

  return $res;
}

sub http_index(@) {
  my $p = named_params @_, [ -url => undef ];
  my $base = $p->{-url};
  return undef unless $base;

  $base .= "/" unless $base =~ /\/$/;

  my $html = http_file -url => $base;
  return () unless $html;

  my @files;
  if ($html =~ /Rolloutd File Listing/) {
    # Internal rolloutd listing format
    fatal "Invalid file list format from $p->{-url}" unless
      $html =~ /<tr id='header'><th>(.*?)<\/th><\/tr>/;
    my @fields = split /<\/th><th>/, $1;
    while ($html =~ /<tr class='file'><td>(.*?)<\/td><\/tr>/mg) {
      my @values = split /<\/td><td>/, $1;
      my %entry = map { $fields[$_] => $values[$_] } 0..$#fields;
      $entry{size} = int($entry{size} || 0);
      $entry{mtime} = int($entry{mtime} || 0);
      push @files, \%entry;
    }
  } else {
    # Look for Apache style directory listing
    while ($html =~ /^(?:<tr><td valign="top">)?<img src="[^"]+" alt="[^"]+">(?:<\/td><td>| )?<a href="([^"]+)">(.+?)<\/a>(?:<\/td>| )/mg) {
      my($filename, $name) = ($1, $2);
      next if !$filename || $name =~ /Parent Directory/i || $filename =~ /\?/;
      push @files, {
        filename => $filename,
        type => ($filename =~ /\/$/) ? "directory" : "file",
        size => 0,
        mtime => 0,
        checksum => "",
      }
    }
  }
  return @files;
}

# Install a whole directory's files
sub dir_install {
  my $p = named_params @_, [ -src => undef, -dest => undef, -cmd => undef, -flags => {},
                             -dir_flags => {}, -mode => undef, -uid => undef, -owner => undef,
                             -gid => undef, -group => undef, -dir_mode => undef ];

  $p->{-dir_flags}{-mode} ||= $p->{-dir_mode} if $p->{-dir_mode};
  $p->{-flags}{-mode} ||= $p->{-mode} if $p->{-mode};
  foreach (qw( uid gid owner group )) {
    $p->{-dir_flags}{-$_} ||= $p->{-$_} if $p->{-$_};
    $p->{-flags}{-$_} ||= $p->{-$_} if $p->{-$_};
  }

  return w "No source specified" unless $p->{-src};
  return w "No destination specified" unless $p->{-dest};

  $p->{-src} =~ s/^rollout:/$config->{base_url}/;
  my $changed = 0;
  d($p);
  if ($p->{-src} =~ /^https?:\/\//) {
    my @files;
    try {
      @files = http_index $p->{-src};
    } catch HttpException with {
      return w "Couldn't retrieve index $p->{-src}: ". shift();
    };
    return w "Empty index $p->{-src}" unless @files;
    foreach (@files) {
      my $filename = $_->{filename};
      if ($_->{type} eq 'directory') {
        # It's a directory
        $filename =~ s/\/$//;
        if (!$p->{-flags}{no_recurse}) {
          v "Recursing into $filename ($p->{-src}/$filename => $p->{-dest}/$filename)";
          dir_install(-src => "$p->{-src}/$filename",
                      -dest => "$p->{-dest}/$filename",
                      -flags => $p->{-flags},
                      -dir_flags => $p->{-dir_flags}) && $changed++;
        }
      } else {
        my @stat = stat("$p->{-dest}/$filename");
        if (@stat && $_->{mtime} <= $stat[9] && $_->{size} == $stat[7]) {
          # Same file size and newer locally, check the checksum to see if it should be skipped
          if (@stat && $_->{checksum}) {
            eval {
              my $md5 = Digest::MD5->new->add(slurp_file("$p->{-dest}/$filename"))->hexdigest;
              if ($md5 && $_->{checksum} && $_->{checksum} eq $md5) {
                v "Skipping $p->{-src}/$filename -> $p->{-dest}/$filename, it's the same";
                $changed += set_attr(-file => "$p->{-dest}/$filename", %{$p->{-flags}});
                next;
              }
            };
          }
        }
        v "Installing file $p->{-src}/$filename to $p->{-dest}/$filename";
        try {
          my $file = http_file -url => "$p->{-src}/$filename";
          text_install(-file => "$p->{-dest}/$filename", -text => $file, -flags => $p->{-flags},
                       -skip_checksum => 1, -flags => $p->{-flags})
            && $changed++;
        } catch HttpException with {
          w "Error retrieving $p->{-src}/$filename: ". shift();
        };
      }
    }
  }

  command($p->{-cmd}) if $changed && $p->{-cmd};
  return $changed ? 1 : 0;
}

#}}}
# i_* functions {{{

sub i_iterate {
  my($key, $func, $m, $donecache) = @_;
  $m ||= $hostname;
  $donecache ||= {};
  my $found = 0;
  return 0 unless $m{$m};
  return 0 if $donecache->{$m}++;
  if ($m{$m}->{$key}) {
    my $x = $func->($m, $m{$m}->{$key});
    return $found unless (defined $x);
    $found += $x;
  }
  $found += i_iterate($key, $func, $_, $donecache) foreach (keys %{$m{$m}->{ISA} || {}});
  return $found;
}

sub i_has {
  my($class, $m) = @_;
  # Return only the first element, which is likely to be the most specific
  my $ret = undef;
  i_iterate($class, sub { $ret = $_[1]; return undef });
  return $ret;
}
eval { memoize('i_has') };

sub _i_in {
  my($grep) = @_;
  return sub { return scalar(grep { $_ eq $grep } @{$_[1]}) }
}

sub i_immutable_file {
  return i_iterate("immutable_file", _i_in($_[0]), $_[1]);
}
eval { memoize('i_immutable_file') };

sub i_unsafe_file {
  return i_iterate("unsafe_file", _i_in($_[0]), $_[1]);
}
eval { memoize('i_unsafe_file') };

sub i_unsafe_dir {
  return i_iterate("unsafe_dir", _i_in($_[0]), $_[1]);
}
eval { memoize('i_unsafe_dir') };

sub i_should {
  my($item, $m) = @_;
  my $step_name = ($current_step =~ /^\d+-(.*)$/)[0];
  my $should_not = 0;
  i_iterate("skip_steps", sub {
    $should_not += 1 if grep { $_ eq "$current_step:$item" } @{$_[1]};
    $should_not += 1 if grep { $_ eq "$step_name:$item" } @{$_[1]};
  });
  return !$should_not;
}
eval { memoize('i_should') };

sub i_isa {
  my($class, $m) = @_;

  $m ||= $hostname;
  return 0 unless $m{$m} && $m{$m}->{ISA};
  return $m{$m}->{ISA}{$class} if $m{$m}->{ISA}{$class};

  foreach (keys %{$m{$m}->{ISA}}) {
    my $ret = i_isa($class, $_);
    return $ret if $ret;
  }
  return 0;
}
eval { memoize('i_isa') };

sub i_isa_fetchall {
  my($class, $m) = @_;
  my @list;
  i_iterate($class, sub { push @list, $_[1] }, $m);
  return @list;
}
eval { memoize('i_isa_fetchall') };

sub i_isa_classes {
  my($class) = @_;

  $class ||= $hostname;

  my %list;
  return () unless $m{$class};

  foreach (keys %{$m{$class}->{ISA} || {}}) {
    if ($m{$class}) {
      $list{$_} = 1 foreach i_isa_classes($_);
    }
    $list{$_} = 1;
  }

  return keys %list;
}
eval { memoize('i_isa_classes') };

sub i_ip {
  my($host) = @_;
  foreach (i_isa_fetchall("interfaces", $host)) {
    while (my($name, $int) = each(%$_)) {
      next unless $int->{primary};
      next unless $int->{gateway};
      next unless $int->{ip};
      return $int->{ip};
    }
  }
  return undef;
}
eval { memoize('i_ip') };

# }}}
# Configuration lookup functions {{{
sub c {
  my($key, $default, $donecache) = @_;
  return wantarray ? () : undef unless $key;
  $donecache ||= {};
  my(@key) = split(/\//, $key);
  my $base = shift @key;
  return wantarray ? () : $default if $donecache->{$base}++;

  my @ret;
  my $x = $m{$base};
  for (my $i = 0; $i <= $#key; $i++) {
    last unless ref $x eq 'HASH';
    $x = $x->{$key[$i]};
    last unless defined($x);
    push @ret, $x if $i == $#key;
  }
  if ($m{$base}->{ISA}) {
    foreach (keys %{$m{$base}->{ISA}}) {
      push @ret, c(join("/", $_, @key), $default, $donecache);
    }
  }
  return wantarray ? @ret : ($ret[0] || $default);
}
eval { memoize('c') };

sub uniq {
  my(@input) = @_;
  my @output;
  my %done;
  foreach (@input) {
    next if $done{$_}++;
    push @output, $_;
  }
  return @output;
}

sub merge_hashes {
  my($x, $y) = @_;
  return [uniq(@$x, @$y)] if ref $x eq 'ARRAY';
  return [uniq($x, $y)] unless ref $x;
  $x->{$_} = defined $x->{$_} ? merge_hashes($x->{$_}, $y->{$_}) : $y->{$_} foreach keys %$y;
  return $x;
}

sub flatten_hash {
  my(@input) = @_;
  my $output = {};
  $output = merge_hashes($output, $_) foreach @input;
  return %$output;
}

sub flatten_list {
  my(@input) = @_;
  my @output = ();
  foreach (@input) {
    push @output, $_ and next unless ref $_ eq 'ARRAY';
    push @output, @$_;
  }
  return @output;
}

sub flatten_list_all {
  my(@input) = @_;
  my @output = ();
  foreach (@input) {
    push @output, $_ and next unless ref $_ eq 'ARRAY';
    push @output, flatten_all(@$_);
  }
  return @output;
}
# }}}
# PriorityQueue {{{
package PriorityQueue;

sub new {
  my $self = { queue => [], prios => {} };
  return bless $self, shift();
}

sub pop {
  my($self) = @_;
  return undef unless @{$self->{queue}};
  delete($self->{prios}->{$self->{queue}->[0]});
  return shift(@{$self->{queue}});
}

sub insert {
  my($self, $payload, $priority, $lower, $upper) = @_;
  $lower ||= 0;
  $upper = scalar(@{$self->{queue}}) - 1 unless defined($upper);
  $self->{prios}->{$payload} = $priority;
  return push(@{$self->{queue}}, $payload) unless @{$self->{queue}};
  return push(@{$self->{queue}}, $payload) if $priority >= $self->{prios}->{$self->{queue}->[-1]};
  return unshift(@{$self->{queue}}, $payload) if $priority < $self->{prios}->{$self->{queue}->[0]};
  return splice(@{$self->{queue}}, 1, 0, $payload) if @{$self->{queue}} == 2;
  my $midpoint;
  while ($upper >= $lower) {
    $midpoint = ($upper + $lower) >> 1;
    if ($priority < $self->{prios}->{$self->{queue}->[$midpoint]}) {
      $upper = $midpoint - 1;
      next;
    }
    $lower = $midpoint + 1;
  }

  splice(@{$self->{queue}}, $lower, 0, $payload);
}

sub _find_payload_pos {
  my($self, $payload) = @_;
  my $priority = $self->{prios}->{$payload};
  return undef unless defined($priority);
  my $lower = 0;
  my $upper = @{$self->{queue}} - 1;
  my $midpoint;
  while ($upper >= $lower) {
    $midpoint = ($upper + $lower) >> 1;
    if ($priority < $self->{prios}->{$self->{queue}->[$midpoint]}) {
      $upper = $midpoint - 1;
      next;
    }
    $lower = $midpoint + 1;
  }
  while ($lower-- >= 0) {
    return $lower if ($self->{queue}->[$lower] eq $payload);
  }
}

sub delete {
  my($self, $payload) = @_;
  my $pos = $self->_find_payload_pos($payload);
  return undef unless defined($pos);
  delete($self->{prios}->{$payload});
  splice(@{$self->{queue}}, $pos, 1);
  return $pos;
}

sub update {
  my($self, $payload, $new_prio) = @_;
  my $old_prio = $self->{prios}->{$payload} || 0;
  my $old_pos = $self->delete($payload);
  my($upper, $lower);
  if ($new_prio - $old_prio > 0) {
    $upper = @{$self->{queue}};
    $lower = $old_pos;
  } else {
    $upper = $old_pos;
    $lower = 0;
  }
  $self->insert($payload, $new_prio, $lower, $upper);
}

package main;

sub queue_step {
  my($step) = @_;

  my($x) = grep /((?:\d+-)?$step)/, @all_steps;
  fatal "Can't find step $step to queue" unless $x;

  v "Queueing step $x";
  $steps->insert($x, 0);
}

my $errors = 0;
sub run_step {
  my($filename) = @_;
  validate("Attempt to run a step with no filename", $filename);
  $current_step = $filename;
  l $filename, 0 unless $no_step_labels;
  try {
    $steps_code{$filename} ||= http_file -url => "steps/$filename";
  } catch HttpException with {
    w "Can't retrieve step $filename: ". shift();
    return;
  };
  try {
    eval $steps_code{$filename};
    $@->throw if $@;
  } catch ConfigException with {
    $errors++;
    w "Configuration error in step $filename:\n". shift();
  } catch StepHelpException with {
    step_help($filename, 1);
  } catch ValidationCompleteException with {
    return;
  } catch Error with {
    if ($@) {
      l "------ FATAL ERROR ------";
      l "$_" foreach ($@);
      my($step, $last_step);
      while (($step = $steps->pop())) {
        $last_step = $step;
      }
      $steps->insert($last_step, 0) if $last_step;
    }
  } finally {
    exit unless $pid == $$;
  };
}

sub step_help {
  my($filename, $indent) = @_;
  validate("Attempt to run a step with no filename", $filename);
  try {
    $steps_code{$filename} ||= http_file -url => "steps/$filename";
  } catch HttpException with {
    w "Can't retrieve step $filename: ". shift();
    return;
  };
  eval {
    require Pod::Text;
  };
  fatal "Could not load Pod::Text module, step help is unavailable: $@" if $@;
  my $parser = new Pod::Text;
  my $output;
  $parser->output_string(\$output);
  $parser->parse_string_document($steps_code{$filename});
  l $output, $indent;
}

# Adds a command to be run just before completion
sub queue_command {
  my($cmd, $prio) = @_;
  $prio = 998 unless defined $prio;
  v "Queueing command $cmd at $prio";
  $steps->insert(sub { command($cmd) }, $prio);
}

# Adds a sub to be run just before completion
sub queue_code {
  my($sub, $prio) = @_;
  $prio = 998 unless defined $prio;
  v "Queueing code $sub at $prio";
  $steps->insert($sub, $prio);
}

# }}}
# File & Directory modification #{{{

sub slurp_file($) {
  my $file = shift;
  local $/;

  my $fh = IO::File->new($file) or throw LocalFileException "Can't open file $file: $!";
  return <$fh>;
}

sub file_append {
  my $p = named_params @_, [ -file => undef, -add => undef, -match => undef, -cmd => undef,
                             -create => 0 ];
  local $_;

  validate("Incorrect parameters to file_append", $p->{-file} && $p->{-add});
  validate("Skipping append of $p->{-file}: $p->{-match} does NOT match '$p->{-add}'",
           defined $p->{-match} && $p->{-add} =~ /$p->{-match}/);

  # Only compare first line for multiline $p->{-add}
  my($firstline) = $p->{-add};
  $firstline =~ s/\n.*$/\n/s;

  unless (-f $p->{-file}) {
    # Touch file.
    return w "$p->{-file} does not exist!" if $safe_mode;
    IO::File->new(">$p->{-file}")->close
      or throw LocalFileException "Unable to create $p->{-file}: $!" if $p->{-create};
  }

  my $t = '';
  my $added = 0;
  my $fh = new IO::File $p->{-file} or throw LocalFileException "Unable to read $p->{-file}: $!";

  while (<$fh>) {
    if ($p->{-match} and /$p->{-match}/) {
      if (/^\Q$firstline\E[\r\n]*/) {
        $fh->close;
        return 0;
      }
      if (!$added) {
        $t .= $p->{-add};
        $t .= "\n" unless $p->{-add} =~ /\n$/;
        $added = 1;
      }
    } else {
      $t .= $_;
    }
  }

  $fh->close;

  if (!$added) {
    $t .= $p->{-add};
    $t .= "\n" unless $p->{-add} =~ /\n$/;
  }

  l "Modified $p->{-file} by appending $p->{-add}";
  safe_write(-file => $p->{-file}, -text => $t);

  if (defined $p->{-cmd} && !$safe_mode) {
    l "Running $p->{-cmd} to finish install of $p->{-file}";
    command($p->{-cmd});
  }

  return 1;
}

sub file_modify {
  my $p = named_params @_, [ -file => undef, -cmd => undef, -modify => [] ];
  my @expr = ref $p->{-modify} eq 'ARRAY' ? @{$p->{-modify}} : [ $p->{-modify} ];
  local $_;

  validate("Incorrect parameters to file_modify", $p->{-file} && @{$p->{-modify} || []});

  (-f $p->{-file}) or return l "$p->{-file} does not exist!";

  my $fh = new IO::File $p->{-file} or throw LocalFileException "Unable to read $p->{-file}: $!";

  my($changes, $f, %c);
  while (<$fh>) {
    my $original = $_;

    foreach my $e (@expr) {
      eval $e;
      throw RolloutException "Regex error in file_modify: $@" if $@;
    }

    $changes++ unless $original eq $_;
    $f .= $_;
  }

  $fh->close;
  return unless $changes;

  l "Modified $p->{-file} with ". join(", ", @expr);
  safe_write(-file => $p->{-file}, -text => $f);

  if (defined $p->{-cmd} && !$safe_mode) {
    l "Running $p->{-cmd} to finish install of $p->{-file}";
    command($p->{-cmd});
  }

  return 1;
}

sub safe_write {
  my $p = named_params @_, [ -file => undef, -text => undef, -mode => undef, -comment => undef ];

  validate("Incorrect parameters to safe_write", $p->{-file} && $p->{-text});

  my($dir, $file) = $p->{-file} =~ /(?:(.*)\/)?(.*)/;
  $p->{-mode} ||= (stat($p->{-file}))[2];
  $p->{-comment} ||= "Rollout";

  return 1 if $safe_mode;

  $dir ||= ".";

  if (!-x "/usr/bin/ci" || i_unsafe_file($file) || i_unsafe_dir($dir)) {
    # RCS is not installed, don't do version control
    safe_write_file(-file => $p->{-file}, -text => $p->{-text});
    chmod $p->{-mode}, $p->{-file} if $p->{-mode};
    return 1;
  }

  my $rcs = "$dir/RCS/$file,v";

  if (-f "$dir/$file") {
    mkdir("$dir/RCS", 0700) if not -d "$dir/RCS" and -w $dir;
    system("ci", "-q", "-m\"Untracked Changes\"", "-t-\"Initial Checkin\"", "-l", "$dir/$file");
    system("rcs", "-q", "-ko", "$dir/$file");
  }

  safe_write_file(-file => $p->{-file}, -text => $p->{-text});

  if (-f "$dir/$file") {
    mkdir("$dir/RCS", 0700) if not -d "$dir/RCS" and -w $dir;
    system("ci", "-q", "-t-\"Initial checkin\"", "-m\"$p->{-comment}\"", "-l", "$dir/$file");
    system("rcs", "-q", "-ko", "$dir/$file");
  }

  chmod $p->{-mode}, $p->{-file} if $p->{-mode};

  return 1;
}

sub safe_write_file {
  my $p = named_params @_, [ -file => undef, -text => undef ];

  validate("Incorrect parameters to safe_write_file", $p->{-file} && $p->{-text});
  my $file = $p->{-file};

  return 1 if $safe_mode;

  my $fh = new IO::File("$file.$$", "w") or throw LocalFileException "Unable to open $file: $!";

  # If the argument is a filehandle, use that.
  if (ref $p->{-file} and defined fileno $p->{-file}) {
    local ($_, $!);
    my $in = $p->{-file};
    while (<$in>) {
      $fh->print($_) or throw LocalFileException "Unable to write $file: $!";
    }
  } else {
    $fh->print($p->{-text}) or throw LocalFileException "Unable to write to $file: $!";
  }

  $fh->close or throw LocalFileException "Unable to close $file: $!";

  rename("$file.$$", $file) or throw LocalFileException "Unable to rename $file.$$: $!";
}

sub lookup_user {
  my($user) = @_;
  local $^W = 0;
  return unless defined $user;
  return $user if int($user) eq $user;
  if (defined(my $uid = getpwnam $user)) {
    return $uid
  }
  w "Can't find user $user";
  return undef;
}
eval { memoize('lookup_user') };

sub lookup_group {
  my($group) = @_;
  local $^W = 0;
  return unless defined $group;
  return $group if int($group) eq $group;
  if (defined(my $uid = getgrnam $group)) {
    return $uid
  }
  w "Can't find group $group";
  return undef;
}
eval { memoize('lookup_group') };

sub set_attr {
  my $p = named_params @_, [ -file => undef, -mode => undef, -uid => undef, -gid => undef,
                             -owner => undef, -group => undef, -flags => {}];
  $p->{-file} ||= $p->{-dir};
  $p->{$_} ||= $p->{-flags}{$_} foreach keys %{$p->{-flags}};
  validate("set_attr called with no filename", $p->{-file});
  my($mode, $uid, $gid);

  for ($p->{-mode}) {
    last unless defined;
    if (/^\d+$/) {
      $mode = $_ & 07777;
    } elsif (/^([r-][w-][stx-]){3}$/) {
      $mode = 0;
      my $shift = 2;
      for (/^(...)(...)(...)$/) {
        $mode |= 1 <<  (9 + $shift)       if s/[st]/x/;
        $mode |= 1 << (($shift * 3) + 2)  if /r/;
        $mode |= 1 << (($shift * 3) + 1)  if /w/;
        $mode |= 1 <<  ($shift * 3)       if /x/;
        $shift--;
      }
    } else {
      throw ConfigException "Invalid mode for $p->{-file}: $_";
    }
  }

  $uid = lookup_user($p->{-owner} || $p->{-uid});
  $gid = lookup_group($p->{-group} || $p->{-gid});

  return 0 unless defined $mode or defined $uid or defined $gid;

  my @stat = stat $p->{-file};
  unless (@stat) {
    # May not exist yet
    throw LocalFileException "Can't stat $p->{-file}: $!" unless $safe_mode;
    @stat = (-1, -1, -1, -1, -1, -1);
  }

  my @changes;
  if (defined $uid and $stat[4] != $uid) {
    push @changes, "owner=$uid";
  } else {
    $uid = $stat[4];
  }

  if (defined $gid and $stat[5] != $gid) {
    push @changes, "group=$gid";
  } else {
    $gid = $stat[5];
  }

  if (defined $mode and ($stat[2] & 07777) != $mode) {
    push @changes, sprintf("mode=0%o", $mode);
  }

  if (@changes) {
    l "Changing attributes of $p->{-file}: ". join(", ", @changes);
    unless ($safe_mode) {
      if (defined $mode and ($stat[2] & 07777) != $mode) {
        chmod $mode, $p->{-file} or
          throw LocalFileException sprintf("chmod %o %s failed: $!", $mode, $p->{-file});
      }
      if ($uid != $stat[4] or $gid != $stat[5]) {
        chown $uid, $gid, $p->{-file} or
          throw LocalFileException sprintf("chown %d:%d %s failed: $!", $uid, $gid, $p->{-file})
          unless $safe_mode;
      }
    }
  }

  return scalar @changes;
}

sub text_install {
  my $p = named_params @_, [ -file => undef, -text => undef, -cmd => undef, -flags => {},
                             -skip_checksum => undef ];
  validate("text_install called with no filename" => $p->{-file});
  validate("text_install called without text for $p->{-file}", defined $p->{-text});

  my $changed = 1;

  # Create containing directory if it doesn't exist
  my $path = dirname($p->{-file});
  dir_check(-dir => $path) if $path and $path ne $p->{-file} and ! -d $path;

  $p->{-flags}->{srcfn} ||= "text";

  # If they are the same, don't bother ..
  #   and they can't have the same md5 if they're different sizes ..

  eval {
    if (!$p->{-skip_checksum} and -f $p->{-file} and -s _ == length($p->{-text})) {
      my $src_md5 = Digest::MD5->new->add($p->{-text})->hexdigest;
      my $dst_md5 = Digest::MD5->new->add(slurp_file $p->{-file})->hexdigest;
      $changed = 0 if $src_md5 eq $dst_md5;
    }
  };

  if ($changed) {
    throw ConfigException "Multiple sources for \"$p->{-file}\":\n".
                          join("\n", @{$p->{-flags}->{srcfn}})
      if ref($p->{-flags}->{srcfn}) eq 'ARRAY';
    l "Installing $p->{-file} from $p->{-flags}->{srcfn}";
    d $p->{-text};
    try {
      safe_write(-file => $p->{-file}, -text => $p->{-text})
    } catch LocalFileException with {
      my $ex = shift;
      $ex->throw("Unable to install $p->{-file}: ". $ex);
    };
  }

  $changed += set_attr($p);
  if ($changed and defined $p->{-cmd}) {
    l "Running $p->{-cmd} to finish install of $p->{-file}";
    command($p->{-cmd});
  }

  $changed;
}

sub file_install {
  my $p = named_params @_, [ -file => undef, -src => undef, -cmd => undef, -flags => {},
                             -modify => [] ];
  validate("Incorrect parameters to file_install", $p->{-file} && $p->{-src});
  my @expr = ref $p->{-modify} eq 'ARRAY' ? @{$p->{-modify}} : [ $p->{-modify} ];
  my $srctext;

  $p->{-src} =~ s/^rollout:/$config->{base_url}/;
  if ($p->{-src} =~ /^https?:\/\//) {
    try {
      local $_;
      $_ = http_file -url => $p->{-src};
      foreach my $e (@expr) {
        eval $e;
      }
      $srctext = $_;
    } catch HttpException with {
      w "Couldn't retrieve $p->{-src}: ". shift();
    };
  } elsif (-s $p->{-src}) {
    if (@expr) {
      my $fh = new IO::File $p->{-src} or throw LocalFileException "Unable to read $p->{-src}: $!";
      local $_;
      while (<$fh>) {
        foreach my $e (@expr) {
          eval $e;
        }
        $srctext .= $_;
      }

      $fh->close;
    } else {
      $srctext = slurp_file $p->{-src};
    }
  }

  return unless defined $srctext;
  $p->{-flags}{srcfn} ||= $p->{-src};
  $p->{-text} = $srctext;
  return text_install($p);
}

sub dir_check {
  my $p = named_params @_, [ -dir => undef, -mode => undef, -uid => undef, -gid => undef ];
  validate("Incorrect parameters to dir_check", $p->{-dir});
  my $flags;
  throw LocalFileException "Existing $p->{-dir} is not a directory" if -e $p->{-dir} && ! -d _;
  return set_attr($p) if -d _;

  # make parent if required
  (my $parent = $p->{-dir}) =~ s/\/[^\/]+$//;
  if ($parent && !-e $parent) {
    my $x = {%$p};
    $x->{-dir} = $parent;
    dir_check($x);
  }
  $p->{-mode} ||= 0755;

  l sprintf("Creating directory %s with mode 0%o", $p->{-dir}, $p->{-mode});
  return 1 if $safe_mode;

  my $mask = umask 0;
  mkdir $p->{-dir}, $p->{-mode}
    or throw LocalFileException "Can't create directory $p->{-dir}: $!";
  umask $mask;
  return 1;
}

sub symlink_check {
  my $p = named_params @_, [ -src => undef, -dest => undef ];
  validate("Incorrect parameters to symlink_check", $p->{-src} && $p->{-dest});
  if (-l $p->{-dest}) {
    return 0 if (readlink $p->{-dest}) eq $p->{-src};
    l "Changing target of symlink $p->{-dest} to $p->{-src}";
    unless ($safe_mode) {
      unlink $p->{-dest} or throw LocalFileException "Can't unlink $p->{-dest}: $!";
      symlink $p->{-src}, $p->{-dest}
        or throw LocalFileException "Can't symlink $p->{-src} to $p->{-dest}: $!";
    }

    return 1
  }

  throw LocalFileException "$p->{-dest} is not a symlink" if -e _;
  unless ($safe_mode) {
    l "Creating symlink from $p->{-src} to $p->{-dest}";
    symlink $p->{-src}, $p->{-dest}
      or throw LocalFileException "Can't symlink $p->{-src} to $p->{-dest}: $!";
  }

  return 1
}

#}}}
# file_[un]comment {{{
# file, comment directive, command to run, list of regexps matching lines to replace

sub file_comment_spec {
  my $p = named_params @_, [ -file => undef, -pat => '#', -cmd => undef, -match => [] ];
  my @regex = ref $p->{-match} eq 'ARRAY' ? @{$p->{-match}} : [ $p->{-match} ];
  local $_;

  return w "$p->{-file} does not exist!" unless -f $p->{-file};

  my $fh = new IO::File $p->{-file} or throw LocalFileException "Unable to read $p->{-file}: $!";
  my($changes, $f, %c);
  while (<$fh>) {
    if (! /^$p->{-pat}/) {
      foreach my $r (@regex) {
        if (/$r/) {
          s/^/$p->{-pat}/;
          $changes++;
          $c{$r}++;
          last;
        }
      }
    }

    $f .= $_;
  }
  $fh->close;
  return unless $changes;

  safe_write(-file => $p->{-file}, -text => $f);

  l "$p->{-file} changed: commented out ". join(', ', keys %c);

  if (defined $p->{-cmd}) {
    v "Running $p->{-cmd} to finish install of $p->{-file}";
    command($p->{-cmd});
  }

  return $changes;
}

sub file_comment {
  my $p = named_params @_, [ -file => undef, -cmd => undef, -match => [], -pat => '#' ];
  return file_comment_spec($p->{-file}, $p->{-pat}, $p->{-cmd}, $p->{-match});
}

sub file_uncomment_spec {
  my $p = named_params @_, [ -file => undef, -pat => '#', -cmd => undef, -match => [] ];
  my @regex = ref $p->{-match} eq 'ARRAY' ? @{$p->{-match}} : [ $p->{-match} ];

  return w "$p->{-file} does not exist!" unless -f $p->{-file};

  my $fh = new IO::File $p->{-file} or throw LocalFileException "Unable to read $p->{-file}: $!";
  my($changes, $f, %c);
  while (<$fh>) {
    foreach my $r (@regex) {
      if (/$p->{-pat}.*$r/) {
        s/^$p->{-pat}+//;
        $changes++;
        $c{$r}++;
        last;
      }
    }
    $f .= $_;
  }
  $fh->close;
  return unless $changes;

  safe_write(-file => $p->{-file}, -text => $f);

  l "$p->{-file} changed: uncommented ". join(', ', keys %c);

  if (defined $p->{-cmd}) {
    v "Running $p->{-cmd} to finish install of $p->{-file}";
    command($p->{-cmd});
  }

  return $changes;
}

sub file_uncomment {
  my $p = named_params @_, [ -file => undef, -cmd => undef, -match => [], -pat => '#' ];
  return file_uncomment_spec($p->{-file}, $p->{-pat}, $p->{-cmd}, $p->{-match});
}
#}}}
# Package Installation {{{

$ENV{DEBIAN_FRONTEND} = 'noninteractive';
sub apt {
  my(@packages) = @_;
  v "Installing ". join(" ", @packages);
  command("apt-get -qq update") unless $m{$hostname}->{_done_apt_update}++;
  if (-x "/usr/bin/dpkg") {
    return command("apt-get", "-qy", "-oStopOnError=false", "-oDPkg::Options={\"--force-confold\"}",
                   "--force-yes", "--allow-unauthenticated", "install", @packages);
  } else {
    return command("apt-get", "-qy", "--force-yes", "install", @packages);
  }
}

sub package_status {
  my($package) = @_;

  if (-f "/etc/debian_version") {
    return package_status_dpkg($package);
  } elsif (-f "/etc/redhat-release") {
    return package_status_rpm($package);
  }
}

sub package_status_dpkg {
  my($package) = @_;
  my $status = $m{$hostname}->{_pkg_status};
  if (!$status) {
    $status = {};
    my $text = slurp_file("/var/lib/dpkg/status");
    foreach (split(/\n\n/, $text)) {
      if (/^Package: (.*)$/m) {
        my $pkg = $1;
        if (/^Status:.* installed.*$/m) {
          $status->{$pkg} = 1;
        } else {
          $status->{$pkg} = 0;
        }
      }
    }
    $m{$hostname}->{_pkg_status} = $status;
  }
  return $status->{$package} || 0;
}

sub package_status_rpm {
  my($package) = @_;
  my $status = $m{$hostname}->{_pkg_status} || {};
  $m{$hostname}->{_pkg_status} = $status;

  if (!defined $status->{$package}) {
    my $return_pkg_val = `rpm -q $package --queryformat "%{NAME}.%{ARCH}\n"`;
    $status->{$package} = $?;
    if (($status->{$package} == 0) && ($return_pkg_val =~ m/^\Q$package/)) {
      $status->{$package} = 0;
    } else {
      $status->{$package} = 1;
    }
  }

  return $status->{$package};
}

sub package_check {
  my(@packages) = @_;

  my $available_packages = $m{$hostname}->{_available_packages};
  $m{$hostname}->{_done_packages} ||= {};

  my @add;
  foreach my $package (@packages) {
    next if $m{$hostname}->{_done_packages}{$package}++;
    next if package_status($package);
    next if $package =~ /^(https?:\/\/|rollout:)/;
    push @add, $package;
  }

  my $changes = 0;
  if (@add) {
    if (!$available_packages) {
      v "Updating packages list";
      command("apt-get -q update") unless $m{$hostname}->{_done_apt_update}++;
    }

    l "Installing packages ". join(" ", @add);
    apt(@add) && $changes++;
  }

  foreach my $url (@packages) {
    $url =~ s/^rollout:/$config->{base_url}/;
    next unless $url =~ /^(https?:\/\/[^\/]+).*\/([a-z0-9\._\-]+\.(?:deb|rpm))/i;

    my($package, $filename) = ($2, $2);
    $package =~ s/[_-]\d+.*//;

    next if $m{$hostname}->{_done_packages}{$package}++;
    next if package_status($package);

    l "Installing $package from $url";

    if ($filename =~ /\.rpm$/) {
      command("rpm", "-U", $url) && $changes++;
    } else {
      try {
        my $data = http_file -url => $url;
        my $fh = new IO::File "/tmp/$filename", "w"
          or throw LocalFileException "Unable to write to /tmp/$filename: $!";
        print $fh $data;
        $fh->close;

        if ($filename =~ /\.deb$/) {
          command("dpkg", "-i", "/tmp/$filename") && $changes++;
        } else {
          w "Unknown package type for $url";
        }

        unlink("/tmp/$filename");
      } catch HttpException with {
        w "Couldn't retrieve package from $url". shift();
      };
    }
  }

  return $changes ? 1 : 0;
}

sub package_uncheck {
  my(@packages) = @_;

  $m{$hostname}->{_done_packages} ||= {};

  my @remove;
  foreach my $package (@packages) {
    next if $m{$hostname}->{_done_packages}{$package}++;
    next unless package_status($package);
    push @remove, $package;
  }

  if (@remove) {
    l "Removing packages ". join(" ", @remove);
    command("apt-get", "-qq", "-y", "remove", @remove);
  }
}
#}}}
# Revision Control Systems checkouts {{{

sub cvs_checkout {
  my $p = named_params @_, [ -dest => undef, -module => undef, -rev => undef, -repo => undef,
                             -cmd => undef ];
  validate("Not enough parameters specified to cvs_checkout",
           $p->{-dest}, $p->{-module}, $p->{-repo});

  v "CVS checkout $p->{-dest}:". ($p->{-rev} || "notag");
  if (-d $p->{-dest} && !-d "$p->{-dest}/CVS") {
    w "$p->{-dest} exists but is not a CVS checkout";
    return 0;
  }
  if (-d $p->{-dest}) {
    chdir $p->{-dest};
    command("cvs", "-q", "update", "-dPA", ($p->{-rev} ? ("-r", $p->{-rev}) : ()));
    command($p->{-cmd}) if $p->{-cmd};
    return 1;
  } else {
    my($base, $newdir) = $p->{-dest} =~ /(.+)\/(.+)/;
    validate("Can't parse dir $p->{-dest}", $base, $newdir);
    try {
      dir_check($base);
    } catch LocalFileException with {
      throw LocalFileException "Checkout to $p->{-dest} failed: ". shift;
    };
    chdir $base unless $safe_mode;
    command("cvs", "-d", $p->{-repo}, "-q", "checkout", "-P",
            ($p->{-rev} ? ("-r", $p->{-rev}) : ()), "-d", $newdir, $p->{-module});
    chdir $p->{-module} && command($p->{-cmd}) if $p->{-cmd} && !$safe_mode;
    return 1;
  }
  return 0;
}

sub svn_checkout {
  my $p = named_params @_, [ -dest => undef, -url => undef, -rev => undef, -cmd => undef ];
  validate("Not enough parameters specified to svn_checkout", $p->{-dest}, $p->{-url});

  v "svn checkout $p->{-dest}:". ($p->{-rev} || "HEAD");
  if (-d $p->{-dest} && !-d "$p->{-dest}/.svn") {
    w "$p->{-dest} exists but is not a svn checkout";
    return 0;
  }
  if (-d $p->{-dest}) {
    chdir $p->{-dest};
    command("svn", "update", ($p->{-rev} ? ("-r", $p->{-rev}) : ()));
    command($p->{-cmd}) if $p->{-cmd};
    return 1;
  } else {
    my($base, $newdir) = $p->{-dest} =~ /(.+)\/(.+)/;
    validate("Can't parse dir $p->{-dest}", $base, $newdir);
    try {
      dir_check($base);
    } catch LocalFileException with {
      throw LocalFileException "Checkout to $p->{-dest} failed: ". shift;
    };
    chdir $base;
    command("svn", "checkout", ($p->{-rev} ? ("-r", $p->{-rev}) : ()), $p->{-url}, $newdir);
    chdir $newdir && command($p->{-cmd}) if $p->{-cmd};
    return 1;
  }
  return 0;
}

# }}}

my %_done_remote_require;
sub remote_require($;$) {
  my($module, $optional) = @_;
  my $filename = $module =~ /\.pm$/ ? $module : "$module.pm";
  if (!$_done_remote_require{$filename}) {
    $_done_remote_require{$filename} = 1;
    my $text;
    try {
      $text = http_file($filename);
    } catch HttpException with {
      return 0 if $optional;
      fatal "Can't load module $module: ". shift;
    };
    if (!$text) {
      return 0 if $optional;
      fatal "Can't load module $module: empty module code";
    }
    eval($text);
    if ($@) {
      return 0 if $optional;
      fatal "Can't load module $module: $@";
    }
  }
  return 1;
}

sub validate($@) {
  my($message, @checks) = @_;
  foreach (@checks) {
    next if $_;
    if ($verbosity > 1) {
      eval {
        require Carp;
        $message .= Carp::longmess;
      };
    }
    throw ConfigException $message;
  }
}

sub validate_config($) {
  remote_require "RolloutConfigValidator" or return;
  my $validator = new RolloutConfigValidator;
  if ($validate_mode) {
    eval {
      $validator->validate_config($_[0], $hostname);
    };
    if ($@) {
      l $@;
      $errors++;
    }
    throw ValidationCompleteException "Validation OK" if $validate_mode;
  } else {
    $validator->validate_config($_[0], $hostname);
  }
}

# An optional hashref as the last argument can set custom messages:
#   failure - print this if command fails.
#   success - print this if command succeeds and produces output. (quiet otherwise)
#   intro   - print this before running the command (and suppress "success")
sub command {
  my $flags = {};
  $flags = pop @_ if ref $_[-1] eq 'HASH';

  my $command = join " ", @_;
  my $printed = 0;
  $flags->{intro} ||= '';
  $flags->{failure} ||= "FAILED: '$command' failed.";
  $flags->{success} ||= "Finished running '$command'.";
  $flags->{timeout} = undef unless $flags->{timeout};

  v "CMD: $command";
  $printed++ if $verbosity > 1;

  return if $safe_mode;

  print $flags->{intro} if $flags->{intro};

  my $cmd = IO::File->new;
  my $child = $cmd->open('-|');
  unless ($child) {
    fatal "Can't fork in command: $!" unless defined $child;

    $SIG{PIPE} = 'IGNORE';

    # detach from controlling tty
    setsid;
    open STDIN, '</dev/null';
    open(STDERR, '>&STDOUT');

    $|=1;
    exec @_;
    die "Can't execute ". join (" ", @_). ": $!";
    exit;
  }

  local $_;
  my $timed_out = 1;
  my $out = length $flags->{intro};
  my $nl = $flags->{intro} =~ /\n$/;

  my $s = IO::Select->new($cmd);
  while ($s->can_read($flags->{timeout})) {
    unless ($cmd->sysread($_, 1024)) {
      $timed_out = 0;
      last;
    }

    my $t;
    $t = "  CMD: " if $nl or !$out;
    s/\n(?=.)/\n  CMD: /g;
    $t .= $_;
    if (!$printed) {
      l "CMD: $command";
      $printed++;
    }
    print $t;
    $log .= $t;

    $out += length;
    $nl = /\n$/;
  }

  if ($timed_out) {
    print "[timeout]\n";
    kill 15, $child;
  } else {
    print "\n" if $out and !$nl;
  }

  $cmd->close;
  if ($? >> 8) {
    l $flags->{failure}. "  Exit code: " . ($? >> 8);
  } elsif ($?) {
    l $flags->{failure}. "  Signal: " . ($? & 0x7f);
  } elsif ($out and not exists $flags->{intro}) {
    l $flags->{success};
  }

  # emulate a return of system()
  return $?;
}

sub expand_network($) {
  my($network) = @_;
  return () unless $network;
  $network =~ s/(^\[|\]$)//g;
  return ($network) if $network =~ /^\d+\.\d+\.\d+\.\d+/;
  return @{$networks{$network} || []};
}

sub read_config {
  my $fh = new IO::File $configfile
    or throw LocalFileException "Unable to read config $configfile: $!";
  my $newconfig = {%$config};
  while (<$fh>) {
    s/[\r\n]+$//;
    next if /^\s*#/;
    my($key, $value) = split /\s*=\s*/, $_, 2;
    next unless $key && $value;
    $newconfig->{$key} = $value;
  }
  $fh->close;
  return $config = $newconfig;
}

sub write_config {
  text_install(-file => $configfile,
               -text => join("", map { "$_ = $config->{$_}\n" } keys %$config));
}

# Load some optional modules
eval { require Digest::MD5 };
w "Digest::MD5 is not installed, file checksums cannot be calculated." if $@;

if (open(LOCKFILE, ">/var/run/rollout.lock")) {
  die "There is already an instance of rollout running"
    unless flock(LOCKFILE, LOCK_EX | LOCK_NB);
}

$start_time = time;
try {
  read_config();
} catch LocalFileException with {
  w shift();
};

sub usage {
  require Pod::Usage;
  Pod::Usage::pod2usage(-exitval => 1, -verbose => 99, -sections => "NAME|SYNOPSIS|OPTIONS");
}

# Read the rest of the options
Getopt::Long::Configure(qw( default bundling auto_version ));
Getopt::Long::GetOptions(
  "configdir=s"     => \$configdir,
  "configfile=s"    => \$configfile,
  "force|f=s"       => \@force_dangerous,
  "hostname|h=s"    => \$hostname,
  "only|o=s"        => \@only_steps,
  "quiet|q"         => sub {},
  "safe_mode|s"     => \$safe_mode,
  "skip_step|k=s"   => \@skip_steps,
  "url|u=s"         => \$config->{base_url},
  "verbose|v"       => sub {},
  "no_step_labels"  => \$no_step_labels,
  "help|?"          => \&usage,
  "step_help|H=s"   => \@step_help,
  "validate"        => sub { $safe_mode = 1; $validate_mode = 1; $no_step_labels = 1 },
) or usage();
@ARGV = @oldargv;

try {
  @all_steps = http_index "steps";
} catch HttpException with {
  fatal("Can't find any steps to execute: ". shift());
  exit(1);
};
unshift @only_steps, "setup", "os-detection", "modifiers" if @only_steps;
push @only_steps, "complete" if @only_steps;
v "Only running steps: " . join(", ", @only_steps) if @only_steps;

$steps = new PriorityQueue;
foreach (@all_steps) {
  next if $_->{type} eq 'directory';
  next unless $_->{filename} =~ /^(\d+)-(.*)/;
  $steps->insert($_->{filename}, int($1));
}

if (@step_help) {
  # Show help for some steps
  while ((my $step = $steps->pop())) {
    next unless grep { $step =~ /^\d*-?$_$/ } @step_help;
    step_help($step, 0);
    print "\n";
  }
  exit(0);
}

# Run the first step (001-setup)
run_step($steps->pop());

# Allow steps to be reordered and duplicated
my @reorder_steps = flatten_list(c("$hostname/rollout/reorder_steps"));
for (my $i = 0; $i < @reorder_steps; $i += 2) {
  $steps->update($reorder_steps[$i], $reorder_steps[$i + 1]);
}
my @copy_steps = flatten_list(c("$hostname/rollout/copy_steps"));
for (my $i = 0; $i < @copy_steps; $i += 2) {
  $steps->insert($copy_steps[$i], $copy_steps[$i + 1]);
}

while ((my $step = $steps->pop())) {
  next if grep { $step =~ /^\d*-?$_$/ } @skip_steps;
  next if @only_steps && !grep { $step =~ /^\d*-?$_$/ } @only_steps;
  next unless i_should('*'); # skip_steps => [ 'foobar:*' ]

  if (ref $step eq 'CODE') {
    $step->();
  } else {
    run_step($step);
  }
}

write_config();
close(LOCKFILE);
unlink("/var/run/rollout.lock");

exit $errors;

__END__
=head1 NAME

rollout - Rollout is a tool designed to automate system administration on UNIX servers.

=head1 SYNOPSIS

rollout [options] <message>

=head1 OPTIONS

=over 4

=item B<--help -?>

Brief help message

=item B<--verbose -v>

Increase verbosity

=item B<--quiet -q>

Don't print anything except fatal errors

=item B<--safe_mode -s>

Show what will be changed, but don't actually do anything

=item B<--validate>

Run the configuration validation part of each step, but don't actually do anything. Implies
L<--safe_mode> and L<--no_step_labels>.

=item B<--url -u> <url>

Set the base Rollout HTTP url

=item B<--skip_step -k> <step>

Specify a step to be skipped, may be specified multiple times

=item B<--hostname -h> <hostname>

Rollout configuration for a different host. If -f network is provided, the
hostname will be changed

=item B<--only -o> <step>

Only run a specific step (can be specified multiple times)

=item B<--force -f> <step>

Force a dangerous step to be run

=item B<--configdir> <path>

Directory to store configuration files

=item B<--configfile> <filename>

File to store configuration (inside configdir unless full path)

=item B<--no_step_labels>

Don't print the filename of each step as it's run.

=back

Steps which are considered dangerous are always run in safe mode, unless the -f
parameter is specified with a step name as argument.

Any additional arguments will be combined to form the 'comment' which will be
logged.  This should be used to describe the reason for running rollout, i.e. a
change tracking number or authorization

=head1 DESCRIPTION

Rollout is a system developed to automate system administration on UNIX servers.
It is primarily focused towards Linux, but could be adapted to Solaris, HP-UX,
AIX, etc.

It is written purely in Perl, and the configuration is also a Perl source file.
Some Perl knowledge is required to edit the configuration, but copy-and-paste
may suffice.

System Administration can generally be reduced to a set of steps, which must be
completed in order.  Some example steps include:

=over 4

=item * Copy files, create symlinks

=item * Edit configuration files

=item * Start / stop services

=item * Add / modify users & groups

=item * Install applications

=back

The idea behind Rollout is to automate all these steps in a configurable way.
Rollout is by design idempotent - it can be run many times on a single server
and produce the same results.

=head1 SEE ALSO

=head1 COPYRIGHT

Copyright 2007 David Parrish

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA  02111-1307  USA

=cut

